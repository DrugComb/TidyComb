---
title: "TidyComb Pipeline"
author: "Shuyu Zheng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TidyComb Pipeline}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r Loading_package, message=FALSE, warning=FALSE}
library("dplyr")
library("TidyComb")
```
# Input Data
Let's start to data preparing with a "template" table which was provided by users or generated by yourself according to some public drug combination data. We provide an example in our package for reference:
```{r Input_data}
template <- read.csv(system.file("extdata", "template.csv",
                                 package = "TidyComb"),
                     stringsAsFactors = FALSE)
head(template)
```

# 1. Prepare cell line information


## 1.1 Generating 'cell_line', 'tissue', 'disease' and index table 'cell_id'.

## 1.1 Matched cellosaurus accession.
```{r Match_cell_accession, message=FALSE}
cells <- unique(na.omit(template$cell_line_name))
cell.match <- MatchCellAcc(cells)
print(cell.match)
```

**Note**: At this step, manually check the matched table and make sure we use the correct cellosaurus accession for further process. Searching conflict cell lines on [ExpasyCellosaurus](https://web.expasy.org/cellosaurus)web page may be helpful.

In this case, cell line _U87_ was matched with two different records. We pick the first one (from "ATCC" company) and generate a "cell line name" - "cellosaurus accession" index table for further data processing.

```{r clean_cell_accession}
cell.match.clean <- cell.match[-2, c("input_name", "cellosaurus_accession")]
```

## 1.2 Generate files according to cellosaurus accessions.

```{r Generate_cell_line}
cell <- GenerateCell(cell.match.clean$cellosaurus_accession)
names(cell)

```

`GenerateCell()` function generates 4 data frames:
* `cell_line`: the **cell_line** table ready for uploading to DrugComb.
* `tissue`: the **tissue** table ready for uploading to DrugComb.
* `disease`: the **disease** table ready for uploading to DrugComb.
* `cell_id`: an index table for matching drug `cell_line_id` with `cellosaurus accession`.

## 1.3 Generate "cell_line_id" column in "template" 
Output list from section _1.1.2_ contains another table `cell_id`. Let's use it to generate the `cell_line_id` for `template`.
```{r Generate_cell_id}
cell.index <- cell.match.clean %>% 
  left_join(cell$cell_id, by = "cellosaurus_accession") %>% 
  select(input_name, id)
template$cell_line_id <- cell.index$id[match(template$cell_line_name, cell.index$input_name)]
names(template)
```
  
# 2. Prepare Drug information

## 2.1 Get correct CIDs for drug

```{r Get_CID}

drug.input <- c(template$drug_row, template$drug_col)
cid.input <- c(template$drug_row_cid, template$drug_col_cid)
drug.cid.input <- unique(data.frame(drug.input, cid.input, stringsAsFactors = FALSE))
print(drug.cid.input)
```


The CID of "BENDAMUSTINE" is missing. In this cases, we can use function `GetCid()` find its CID by searching drug names in PubChem Compound database.

```{r matching_cid, message=FALSE, warning=FALSE}
match.cid <- GetCid(ids = "BENDAMUSTINE", type = "name")
print(match.cid)
```

```{r}
cids <- c(match.cid$cid, na.omit(drug.cid.input$cid.input))
```


## 2.2 Generating "drug" file
```{r Genenrate_drug, message=FALSE}
drug <- GenerateDrug(cids)
names(drug)
```

`GenerateDrug()` function generates data frames:
* `drug`: the **drug** table ready for uploading to DrugComb.
* `drug.id`: an index table for matching drug `drug_id` with `cid`.

## 2.3 add "drug_id" to "template"
```{r Generate_drug_id}
drug_index <- drug$drug_id
template$drug_row_id <- drug_index$id[match(template$drug_row_cid,
                                            drug_index$cid)]
template$drug_col_id <- drug_index$id[match(template$drug_col_cid,
                                            drug_index$cid)]
head(template)
template <- template[, c("block_id", "drug_row_id", "drug_col_id", "response",
                         "conc_r", "conc_c", "conc_r_unit", "conc_c_unit",
                         "cell_line_id")]
```

# 3. calculate synergy scores and generate other files for uploading

```{r Generate_tables, message=FALSE, warning=FALSE}
tables <- pipeline(template)
names(tables)
```

`pipeline` function generates 5 data frames:
* `response_with_score`: a table containing calculated synergy scores of each interaction block.
* `response`: the **response** table ready for uploading to DrugComb.
* `summary`: the **summary** table ready for uploading to DrugComb.
* `surface`: the **curface** table ready for uploading to DrugComb.
* `curve`: the **curve** table ready for uploading to DrugComb.

# Output and check data

```{r Output, eval=FALSE, message=FALSE, warning=FALSE}
dir.create("Upload")
write.csv(cell$cell_line, "Upload/cell_line.csv", row.names = FALSE)
write.csv(cell$tissue, "Upload/tissue.csv", row.names = FALSE)
write.csv(cell$disease, "Upload/disease.csv", row.names = FALSE)
write.csv(drug$drug, "Upload/drug.csv", row.names = FALSE)
write.csv(tables$response, "Upload/response.csv", row.names = FALSE)
write.csv(tables$summary, "Upload/summary.csv", row.names = FALSE)
write.csv(tables$surface, "Upload/surface.csv", row.names = FALSE)
write.csv(tables$curve, "Upload/curve.csv", row.names = FALSE)
```

Now we have put all files required for DrugComb in 'Upload' folder. Before submitting to database, check the content of each file according to **schema**. 
