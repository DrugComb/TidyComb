# TidyComb
# Functions for preparig drug response matrix for drug-response model fitting,
# and synergy scores, CSS, and DSS calculation.
# Copyrighte Shuyu Zheng

#' Impute missing value with nearest values
#'
#' Function \code{ImputeNear} do missing value inputation by assigning the
#' average of values in nearest 4 cells (top, bottom, left, right) to the NA
#' cell.
#'
#' @param response.mat A matrix which has missing value.
#'
#' @param times a integer which refers to the time of runing imputation. The
#' default value is \code{1}, but sometimes you might want to run imputation
#' more than once.
#'
#' @return A matrix which is same as input matrix except the NA cells are filled
#' with numbers.
#'
#' @export
ImputeNear <- function(response.mat, times = 1) {
  for (i in seq(to = times)) {
  x <- array(c(rbind(response.mat[-1,], NA),
               rbind(NA, response.mat[-nrow(response.mat), ]),
               cbind(response.mat[,-1], NA),
               cbind(NA, response.mat[, -ncol(response.mat)])),
             dim=c(nrow(response.mat), ncol(response.mat), 4))
  x.imp <- apply(x,c(1,2), class)# function(x) mean(x, na.rm = TRUE))
  index.na <- is.na(response.mat)
  response.mat[index.na] <- x.imp[index.na]
  }
  return(response.mat)
}

#' Add noise to response value
#'
#' Function \code{AddNoise} calculates and add a noise to values in response
#' matrix. The methods used to calculate noises are: "random" and "scale".
#'
#' There are two options for calculating noise in this function:
#' \itemize{
#'   \item \strong{random} The noises obey normal distribution ~N(0, 0.001).
#'   They are generated by fucntion \code{\link[stats]rnorm}.
#'   \item \strong{scale} The noises are generated by multiplying the total
#'   number of response values in matrix with 10^-10.
#' }
#'
#' @param response.mat A matrix. It contains the response data for one block of
#' drug combination screen.
#'
#' @param method A characer. It refers to the method used for calculating noise.
#' Available options are "random" and "scale".
#'
#' @return A matrix. It contains the response value added with noises.
#'
#' @export
AddNoise <- function(response.mat, method = "random") {
  if (method == "random") {
    set.seed(1)
    response.mat <- response.mat + stats::rnorm(nrow(data.tmp), 0, 0.001)
  } else if (method == "scale") {
    scale <- 10^-10
    noise <- row(response.mat) * col(response.mat) * scale
    response.mat <- response.mat + noise
  } else {
    stop('The available metods for adding noise are: "random" and "scale".')
  }
}
#' Impute missing value at IC50 concentration of drug
#'
#' \code{ImputeIC50} uses the particular experiment's values to predict the
#' missing values at the desired IC50 concentration of the drug.
#
#' This function is only called when trying to fix a drug at its selected IC50
#' concentration where the response values have not been tested in experiment.
#'
#' \code{ImputeIC50} fits dose-response models (with \code{\link[drc]{drm}}
#' function) by fixing the concentrations of the
#' \strong{other} drug successively, and uses each fit to predict the missing
#' value at the combination (missing IC50, fixed conc).
#'
#' @param response.mat
#'
#' @return a data frame contains all response value at the IC50 concentration
#' of certein drug. It could be directly passed to function
#' \code{\link{computeSensitivity}} for scoring.
#'
#' @export
ImputeIC50 <- function(response.mat, ic_r, ic_c) {

  colconc <- as.numeric(colnames(response.mat))
  rowconc <- as.numeric(rownames(response.mat))
  m_col <- length(colconc)
  m_row <- length(rowconc)

  if (m_row == 2) {
    tempcf_c <- data.frame(conc = as.numeric(colnames(response.mat)),
                           response = response.mat[m_row, ])
  } else {
    response <- apply(response.mat, 2, function(x) {
      data <- data.frame(conc = as.numeric(rownames(response.mat)),
                         response = x)
      if (stats::var(x, na.rm = TRUE) == 0) {
        pred <- x[1]
      } else {
        pred <- tryCatch({
          # model <- drc::drm(response ~ conc,
          #                   data = data[-which(data$conc == 0), ],
          #                   fct = drc::LL.4())
          model <- drc::drm(response ~ conc, data = data, fct = drc::LL.4())

          stats::predict(model, data.frame(conc = ic_r))
        }, error = function(e){
          # model <- drc::drm(response ~ log(conc),
          #              data = data[-which(data$conc == 0), ],
          #              fct = drc::L.4())
          data$conc[1] = 10^-10
          model = drc::drm(response ~ log(conc), data = data, fct = drc::L.4())

          stats::predict(model, data.frame(conc = log(ic_r))) # NB! use log
        }
        )
        if (pred > 100) {
          pred <- 100 + stats::runif(1, -0.01, 0)
        }
      }
      return(pred)
    }
    )
    tempcf_c <- data.frame(conc = as.numeric(colnames(response.mat)),
                           response = response)
  }

  if (m_col == 2) {
    tempcf_r <- data.frame(conc = as.numeric(rownames(response.mat)),
                           response = response.mat[, m_col])
  } else {
    response <- apply(response.mat, 1, function(x) {
      data <- data.frame(conc = as.numeric(colnames(response.mat)),
                         response = x)
      if(stats::var(x, na.rm = T) == 0) {
        pred = x[1]
      } else {
        pred <- tryCatch({
          # model <- drc::drm(response ~ conc,
          #                   data = data[-which(data$conc == 0), ],
          #                   fct = drc::LL.4())
          model <- drc::drm(response ~ conc, data = data, fct = drc::LL.4())
          stats::predict(model, data.frame(conc = ic_c))
        }, error = function(e) {
          data$conc[1] <- 10^-10
          model <- drc::drm(response ~ log(conc), data = data,
                            fct = drc::L.4())
          # model <- drc::drm(response ~ log(conc),
          #                   data = data[-which(data$conc == 0), ],
          #                   fct = drc::L.4())
          stats::predict(model, data.frame(conc = log(ic_c))) # NB! use log
        }
        )
        if (pred > 100) {
          pred <- 100 + stats::runif(1, -0.01, 0)
        }
      }
      return(pred)
    }
    )
    tempcf_r <- data.frame(conc = as.numeric(rownames(response.mat)),
                           response = response)
  }
  tempres <- list(tempcf_c = tempcf_c, tempcf_r = tempcf_r)
  return(tempres)
}