# TidyComb
# Functions for processing drug response matrix.
#
# Functions in this page:
#
# ImputeNear: Impute missing value with nearest values
# AddNoise: Add noise to response value
# ExtractSingleDrug: Extract single drug response from matrix
# CorrectBaseLine: Do base line correction to dose-response matrix.

#' Impute missing value with nearest values
#'
#' Function \code{ImputeNear} do missing value inputation by assigning the
#' average of values in nearest 4 cells (top, bottom, left, right) to the NA
#' cell.
#'
#' @param response.mat A matrix which has missing value.
#'
#' @param times a integer which refers to the time of runing imputation. The
#' default value is \code{1}, but sometimes you might want to run imputation
#' more than once.
#'
#' @return A matrix which is same as input matrix except the NA cells are filled
#' with numbers.
#'
#' @author Shuyu Zheng{shuyu.zheng@helsinki.fi}
#'
#' @export
ImputeNear <- function(response.mat, times = 1) {
  for (i in seq(to = times)) {
  x <- array(c(rbind(response.mat[-1,], NA),
               rbind(NA, response.mat[-nrow(response.mat), ]),
               cbind(response.mat[,-1], NA),
               cbind(NA, response.mat[, -ncol(response.mat)])),
             dim=c(nrow(response.mat), ncol(response.mat), 4))
  x.imp <- apply(x, c(1,2), mean, na.rm = TRUE)
  index.na <- is.na(response.mat)
  response.mat[index.na] <- x.imp[index.na]
  }
  return(response.mat)
}

#' Add noise to response value
#'
#' Function \code{AddNoise} calculates and add a noise to values in response
#' matrix. The methods used to calculate noises are: "random" and "scale".
#'
#' There are two options for calculating noise in this function:
#' \itemize{
#'   \item \strong{random} The noises obey normal distribution ~N(0, 0.001).
#'   They are generated by fucntion \code{\link[stats]{rnorm}}.
#'   \item \strong{scale} The noises are generated by multiplying the total
#'   number of response values in matrix with 10^-10.
#' }
#'
#' \strong{Note}: Random number generator used in \code{AddNoise} with
#' \code{method = "random"}. If the analysis requires for reproductiblity,
#' plesase set the random seed before calling this function.
#'
#' @param response.mat A matrix. It contains the response data for one block
#' of drug combination screen.
#'
#' @param method A characer. It refers to the method used for calculating noise.
#' Available options are "random" and "scale".
#'
#' @return A matrix. It contains the response value added with noises.
#'
#' @author Shuyu Zheng{shuyu.zheng@helsinki.fi}
#'
#' @export

AddNoise <- function(response.mat, method) {
  if (method == "random") {
    noise <- matrix(stats::rnorm(nrow(response.mat) * ncol(response.mat),
                                 0, 0.001),
                    nrow = nrow(response.mat),
                    ncol = ncol(response.mat))
  } else if (method == "scale") {
    scale <- 10^-10
    noise <- row(response.mat) * col(response.mat) * scale
  } else {
    stop('The available metods for adding noise are: "random" and "scale".')
  }
  response.mat <- response.mat + noise
  return(response.mat)
}

#' Extract single drug response from matrix
#'
#' \code{ExtractSingleDrug} extracts the dose-response values of single drug (
#' drug added in column or row) from a drug combination dose-response matrix.
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#' and row name are representing the concerntrations of drug added to column and
#' row, respectively. The values in matrix indicate the inhibition rate to cell
#' growth.
#'
#' @param dim A character. It should be either "col" or "row" to indicate which
#' drug's dose-response value will be extracted.
#'
#' @return A data frame. It contains two variables:
#' \itemize{
#' \item \strong{dose} The concertration of drug.
#' \item \strong{response} The cell's response (inhibation rate) to
#' corresponding drug concertration.
#' }
#'
#' @author Shuyu Zheng{shuyu.zheng@helsinki.fi}
#'
#' @export
ExtractSingleDrug <- function(response.mat, dim = "row") {
  if (dim == "row") {
    single.drug <- data.frame(response = response.mat[, "0"],
                              dose = as.numeric(rownames(response.mat)))
  } else if (dim == "col") {
    single.drug <- data.frame(response = response.mat["0", ],
                              dose = as.numeric(colnames(response.mat)))
  } else {
    stop("Values for 'dim' should be eighther 'row' or 'col'!")
  }
  rownames(single.drug) <- NULL
  return(single.drug)
}

#' Base line correction
#'
#' \code{CorrectBaseLine} adjusts the base line of drug combination
#' dose-response matrix up to positive values.
#'
#' @param response.mat A drug cobination dose-response matrix. It's column name
#' and row name are representing the concerntrations of drug added to column and
#' row, respectively. The values in matrix indicate the inhibition rate to cell
#' growth.
#'
#' @param method A character value to indicate using which method to do
#' baseline correction. Available values ate:
#'   \itemize{
#'     \item \strong{non} means no baseline corection.
#'     \item \strong{part} means only adjust the negative values in the matrix.
#'     \item \strong{all} means adjust all values in the matrix.
#'   }
#'
#' @param ... Other arguments inherited from function
#'   \code{\link{FitDoseResponse}}
#'
#' @return A matrix which base line have been adjusted.
#'
#' @author \itemize{
#'    \item{Liye He \email{liye.he@helsinki.fi}}
#'    \item{Shuyu Zheng \email{shuyu.zheng@helsinki.fi}}
#' }
#'
#' @export
#'
CorrectBaseLine <- function(response.mat,
                            method = c("non", "part", "all"), ...){

  method <- match.arg(method)

  if (method == "non") {
    return(response.mat)
  } else if (method == "part") {
    negative.ind <- which(response.mat < 0, arr.ind = TRUE)
    if (length(negative.ind) == 0) {
      return(response.mat)
    }
    drug.row <- ExtractSingleDrug(response.mat, dim = "row")
    drug.row.fit <- suppressWarnings(stats::fitted(FitDoseResponse(drug.row,
                                                                   ...)))

    drug.col <- ExtractSingleDrug(response.mat, dim = "col")
    drug.col.fit <- suppressWarnings(stats::fitted(FitDoseResponse(drug.col,
                                                                   ...)))

    baseline <- mean(c(min(as.numeric(drug.row.fit)),
                       min(as.numeric(drug.col.fit))))
    response.mat[negative.ind] <- sapply(response.mat[negative.ind],
                                         function(x) {
                                           x - ((100 - x) / 100 * baseline)
                                         })
    return(response.mat)
  } else if (method == "all"){
    drug.row <- ExtractSingleDrug(response.mat, dim = "row")
    drug.row.fit <- suppressWarnings(stats::fitted(FitDoseResponse(drug.row,
                                                                   ...)))

    drug.col <- ExtractSingleDrug(response.mat, dim = "col")
    drug.col.fit <- suppressWarnings(stats::fitted(FitDoseResponse(drug.col,
                                                                   ...)))

    baseline <- mean(c(min(as.numeric(drug.row.fit)),
                       min(as.numeric(drug.col.fit))))
    response.mat <- response.mat - ((100 - response.mat) / 100 * baseline)
    return(response.mat)
  }
}

